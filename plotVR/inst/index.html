<!DOCTYPE html>
<html lang="en">
  <head>
    <title>plotVR</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0, shrink-to-fit=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <style>
    body {
      width: 100%;
      height: 100%;
      background-color: #000;
      color: #fff;
      margin: 0px;
      padding: 0;
      overflow: hidden;
    }

    /* Position the button on the bottom of the page. */
    #ui {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      font-family: 'Karla', sans-serif;
      z-index: 1;
    }

    a#magic-window {
      display: block;
      color: white;
      margin-top: 1em;
    }
    </style>
  </head>
        <!-- we need to close the websocket, else on Chrome (Android/Linux/macOS)
             this somehow backfires and httpuv in the R-session crashes with segfault -->
  <body onkeydown="keyEvent(event)" onclose="closeWebSocket()">
    <div id="ui">
      <div id="vr-button"></div>
      <a id="magic-window" href="#">Try it without a headset</a>
    </div>
  </body>
  <script>
  /*
   * Debug parameters.
   */
  WebVRConfig = {
    /**
     * webvr-polyfill configuration
     */

    // Forces availability of VR mode.
    //FORCE_ENABLE_VR: true, // Default: false.
    // Complementary filter coefficient. 0 for accelerometer, 1 for gyro.
    //K_FILTER: 0.98, // Default: 0.98.
    // How far into the future to predict during fast motion.
    //PREDICTION_TIME_S: 0.040, // Default: 0.040 (in seconds).
    // Flag to disable touch panner. In case you have your own touch controls
    //TOUCH_PANNER_DISABLED: true, // Default: false.
    // Enable yaw panning only, disabling roll and pitch. This can be useful for
    // panoramas with nothing interesting above or below.
    //YAW_ONLY: true, // Default: false.
    // To disable keyboard and mouse controls, if you want to use your own
    // implementation.
    // MOUSE_KEYBOARD_CONTROLS_DISABLED: true, // Default: false.
    // Enable the deprecated version of the API (navigator.getVRDevices).
    //ENABLE_DEPRECATED_API: true, // Default: false.
    // Scales the recommended buffer size reported by WebVR, which can improve
    // performance. Making this very small can lower the effective resolution of
    // your scene.
    BUFFER_SCALE: 0.5, // default: 1.0
    // Allow VRDisplay.submitFrame to change gl bindings, which is more
    // efficient if the application code will re-bind it's resources on the
    // next frame anyway.
    // Dirty bindings include: gl.FRAMEBUFFER_BINDING, gl.CURRENT_PROGRAM,
    // gl.ARRAY_BUFFER_BINDING, gl.ELEMENT_ARRAY_BUFFER_BINDING,
    // and gl.TEXTURE_BINDING_2D for texture unit 0
    // Warning: enabling this might lead to rendering issues.
    //DIRTY_SUBMIT_FRAME_BINDINGS: true // default: false
  };
  </script>

  <!--
    A polyfill for Promises. Needed for IE and Edge.
  -->
  <script src="js/third-party/es6-promise/es6-promise.min.js"></script>

  <!--
    three.js 3d library
  -->
  <script src="js/third-party/three/three.min.js"></script>

  <!--
    VRControls.js acquires positional information from connected VR devices and applies the transformations to a three.js camera object.
  -->
  <script src="js/third-party/three/VRControls.js"></script>

  <!--
    VREffect.js handles stereo camera setup and rendering.
  -->
  <script src="js/third-party/three/VREffect.js"></script>

  <!--
    A polyfill for WebVR using the Device{Motion,Orientation}Event API.
  -->
  <script src="js/third-party/webvr/webvr-polyfill.min.js"></script>

  <!--
    A set of UI controls for entering VR mode.
  -->
  <script src="js/third-party/webvr/webvr-ui.min.js"></script>


  <script>
    // the websocket to home to get keyboard input
    try{
      var wsProtocol = (location.protocol=="https:") ? "wss:" : "ws:";
      var websocket = new WebSocket(wsProtocol+"//"+location.host+"/ws");
      
      websocket.onopen = function() {
          websocket.send('{"device": true}')
        }
      websocket.onmessage = function(msg) {
        if(msg.data.length == 0)
          return;
        console.log("Got message: "+msg.data);
        body = JSON.parse(msg.data)
        if('key' in body){
          handle_char(body['key']);
        }
        //websocket.send("thanks");
      }
      websocket.onclose = function(event){
        console.log('websocket closed.')
      }

    }catch(err){
      console.log(err);
    }

    var DEFAULT_DATA_JSON = "{ \"data\": [[  5.1,3.5,1.4,1],[4.9,3,1.4,1],[4.7,3.2,1.3,1],[4.6,3.1,1.5,1],[5,3.6,1.4,1],[5.4,3.9,1.7,1],[4.6,3.4,1.4,1],[5,3.4,1.5,1],[4.4,2.9,1.4,1],[4.9,3.1,1.5,1],[5.4,3.7,1.5,1],[4.8,3.4,1.6,1],[4.8,3,1.4,1],[4.3,3,1.1,1],[5.8,4,1.2,1],[5.7,4.4,1.5,1],[5.4,3.9,1.3,1],[5.1,3.5,1.4,1],[5.7,3.8,1.7,1],[5.1,3.8,1.5,1],[5.4,3.4,1.7,1],[5.1,3.7,1.5,1],[4.6,3.6,1,1],[5.1,3.3,1.7,1],[4.8,3.4,1.9,1],[5,3,1.6,1],[5,3.4,1.6,1],[5.2,3.5,1.5,1],[5.2,3.4,1.4,1],[4.7,3.2,1.6,1],[4.8,3.1,1.6,1],[5.4,3.4,1.5,1],[5.2,4.1,1.5,1],[5.5,4.2,1.4,1],[4.9,3.1,1.5,1],[5,3.2,1.2,1],[5.5,3.5,1.3,1],[4.9,3.6,1.4,1],[4.4,3,1.3,1],[5.1,3.4,1.5,1],[5,3.5,1.3,1],[4.5,2.3,1.3,1],[4.4,3.2,1.3,1],[5,3.5,1.6,1],[5.1,3.8,1.9,1],[4.8,3,1.4,1],[5.1,3.8,1.6,1],[4.6,3.2,1.4,1],[5.3,3.7,1.5,1],[5,3.3,1.4,1],[7,3.2,4.7,2],[6.4,3.2,4.5,2],[6.9,3.1,4.9,2],[5.5,2.3,4,2],[6.5,2.8,4.6,2],[5.7,2.8,4.5,2],[6.3,3.3,4.7,2],[4.9,2.4,3.3,2],[6.6,2.9,4.6,2],[5.2,2.7,3.9,2],[5,2,3.5,2],[5.9,3,4.2,2],[6,2.2,4,2],[6.1,2.9,4.7,2],[5.6,2.9,3.6,2],[6.7,3.1,4.4,2],[5.6,3,4.5,2],[5.8,2.7,4.1,2],[6.2,2.2,4.5,2],[5.6,2.5,3.9,2],[5.9,3.2,4.8,2],[6.1,2.8,4,2],[6.3,2.5,4.9,2],[6.1,2.8,4.7,2],[6.4,2.9,4.3,2],[6.6,3,4.4,2],[6.8,2.8,4.8,2],[6.7,3,5,2],[6,2.9,4.5,2],[5.7,2.6,3.5,2],[5.5,2.4,3.8,2],[5.5,2.4,3.7,2],[5.8,2.7,3.9,2],[6,2.7,5.1,2],[5.4,3,4.5,2],[6,3.4,4.5,2],[6.7,3.1,4.7,2],[6.3,2.3,4.4,2],[5.6,3,4.1,2],[5.5,2.5,4,2],[5.5,2.6,4.4,2],[6.1,3,4.6,2],[5.8,2.6,4,2],[5,2.3,3.3,2],[5.6,2.7,4.2,2],[5.7,3,4.2,2],[5.7,2.9,4.2,2],[6.2,2.9,4.3,2],[5.1,2.5,3,2],[5.7,2.8,4.1,2],[6.3,3.3,6,3],[5.8,2.7,5.1,3],[7.1,3,5.9,3],[6.3,2.9,5.6,3],[6.5,3,5.8,3],[7.6,3,6.6,3],[4.9,2.5,4.5,3],[7.3,2.9,6.3,3],[6.7,2.5,5.8,3],[7.2,3.6,6.1,3],[6.5,3.2,5.1,3],[6.4,2.7,5.3,3],[6.8,3,5.5,3],[5.7,2.5,5,3],[5.8,2.8,5.1,3],[6.4,3.2,5.3,3],[6.5,3,5.5,3],[7.7,3.8,6.7,3],[7.7,2.6,6.9,3],[6,2.2,5,3],[6.9,3.2,5.7,3],[5.6,2.8,4.9,3],[7.7,2.8,6.7,3],[6.3,2.7,4.9,3],[6.7,3.3,5.7,3],[7.2,3.2,6,3],[6.2,2.8,4.8,3],[6.1,3,4.9,3],[6.4,2.8,5.6,3],[7.2,3,5.8,3],[7.4,2.8,6.1,3],[7.9,3.8,6.4,3],[6.4,2.8,5.6,3],[6.3,2.8,5.1,3],[6.1,2.6,5.6,3],[7.7,3,6.1,3],[6.3,3.4,5.6,3],[6.4,3.1,5.5,3],[6,3,4.8,3],[6.9,3.1,5.4,3],[6.7,3.1,5.6,3],[6.9,3.1,5.1,3],[5.8,2.7,5.1,3],[6.8,3.2,5.9,3],[6.7,3.3,5.7,3],[6.7,3,5.2,3],[6.3,2.5,5,3],[6.5,3,5.2,3],[6.2,3.4,5.4,3],[5.9,3,5.1,3 ]], \"speed\":  0 }\n";

    var speed = 0;

    var connected = false;

    //var keyboard = new THREEx.KeyboardState();

    // ------------ from webvr-boilerplate  ------------
    // Last time the scene was rendered.
    var lastRenderTime = 0;
    // Currently active VRDisplay.
    var vrDisplay;
    // How big of a box to render.
    var boxSize = 5;
    // Various global THREE.Objects.
    var scene;
    var cube;
    var controls;
    var effect;
    var camera;
    // EnterVRButton for rendering enter/exit UI.
    var vrButton;


    function onLoad() {
      // Setup three.js WebGL renderer. Note: Antialiasing is a big performance hit.
      // Only enable it if you actually need to.
      var renderer = new THREE.WebGLRenderer({antialias: true});
      renderer.setPixelRatio(window.devicePixelRatio);

      // Append the canvas element created by the renderer to document body element.
      document.body.appendChild(renderer.domElement);

      // Create a three.js scene.
      scene = new THREE.Scene();
      
      scene.rotation.y = 90

      // Create a three.js camera.
      var aspect = window.innerWidth / window.innerHeight;
      camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 10000);

      controls = new THREE.VRControls(camera);
      controls.standing = true;
      camera.position.y = controls.userHeight;

      // Apply VR stereo rendering to renderer.
      effect = new THREE.VREffect(renderer);
      effect.setSize(window.innerWidth, window.innerHeight);

      window.addEventListener('resize', onResize, true);
      window.addEventListener('vrdisplaypresentchange', onResize, true);

      // Initialize the WebVR UI.
      var uiOptions = {
        color: 'black',
        background: 'white',
        corners: 'square'
      };
      vrButton = new webvrui.EnterVRButton(renderer.domElement, uiOptions);
      vrButton.on('exit', function() {
        // camera.quaternion.set(0, 0, 0, 1);
        // camera.position.set(0, controls.userHeight, 0);
      });
      vrButton.on('hide', function() {
        document.getElementById('ui').style.display = 'none';
      });
      vrButton.on('show', function() {
        document.getElementById('ui').style.display = 'inherit';
      });
      document.getElementById('vr-button').appendChild(vrButton.domElement);
      document.getElementById('magic-window').addEventListener('click', function() {
        vrButton.requestEnterFullscreen();
      });
      
      
      setupStage();
      
      // finally start plotVR rendering in the following:
      
      refreshData();
      // response = JSON.parse(DEFAULT_DATA_JSON);
      // plotData(response.data);

    }


    // Request animation frame loop function
    function animate(timestamp) {
      var delta = Math.min(timestamp - lastRenderTime, 500);
      lastRenderTime = timestamp;

      // Only update controls if we're presenting.
      if (vrButton.isPresenting()) {
        controls.update();
      }
      
      // now if we are flying:
      if(speed > 0){
          go(0, 0, -delta/1000);
      }
      scene.updateMatrixWorld();

      camera.updateProjectionMatrix();
      // Render the scene.
      effect.render(scene, camera);

      vrDisplay.requestAnimationFrame(animate);
    }

    function onResize(e) {
      effect.setSize(window.innerWidth, window.innerHeight);
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
    }

    // Get the HMD, and if we're dealing with something that specifies
    // stageParameters, rearrange the scene.
    function setupStage() {
      navigator.getVRDisplays().then(function(displays) {
        if (displays.length > 0) {
          vrDisplay = displays[0];
          if (vrDisplay.stageParameters) {
            setStageDimensions(vrDisplay.stageParameters);
          }
          vrDisplay.requestAnimationFrame(animate);
        }
      });
    }

    function setStageDimensions(stage) {
      // Make the skybox fit the stage.
      var material = skybox.material;
      scene.remove(skybox);

      // Size the skybox according to the size of the actual stage.
      var geometry = new THREE.BoxGeometry(stage.sizeX, boxSize, stage.sizeZ);
      skybox = new THREE.Mesh(geometry, material);

      // Place it on the floor.
      skybox.position.y = boxSize/2;
      scene.add(skybox);

      // Place the cube in the middle of the scene, at user height.
      cube.position.set(0, controls.userHeight, 0);
    }

    
    // ---- our rendering code ----
    
    var geometryPoint = new THREE.SphereGeometry(0.1, 10, 10);
    var materialPoint = new THREE.MeshBasicMaterial( { color: "green" } );
    // in R: cat(paste(palette(),collapse='","'))
    var colors = [ "black","red","green","blue","cyan","magenta","yellow","gray" ];

    var spheres = [];
    
    function plotData(data){
      if(spheres.length>0){
        for(i=0; i < spheres.length; i++){
          scene.remove(spheres[i]);
        }
      }
      spheres = [];
      for(i=0; i< data.length; i++){
        if(data[i].length>3){
            materialPoint = new THREE.MeshBasicMaterial( { color: colors[data[i][3]] } )
        }
        var sphere = new THREE.Mesh(geometryPoint,materialPoint);
        scene.add(sphere);
        spheres.push(sphere);
        sphere.position.set(data[i][0],data[i][1],data[i][2])
      }
    }
    
    function refreshData(){
      var http_request = new XMLHttpRequest();
      http_request.onreadystatechange  = function(){
        if (http_request.readyState == 4){
          var responseText = http_request.responseText;
          if(responseText.length == 0 || http_request.status == 404){
            responseText = DEFAULT_DATA_JSON;
          }
          response = JSON.parse(responseText);
          plotData(response.data);
          speed = response.speed;
        }
        //setTimeout(refreshData, 4000);
      }
      http_request.open("GET", "data.json", true);
      http_request.send();
    }
    
    function handle_char(msg){
      if(msg == "r"){
        // we need to close the websocket, else on Chrome (Android/Linux/macOS)
        // this somehow backfires and httpuv in the R-session crashes with segfault
        if(websocket != null){
          closeWebSocket();
          location.reload(true);
        }else{
          location.reload(true);
        }
        return;
      }else if(msg == "reload_data" || msg =="x" ){
        refreshData();
      // }else if(msg === "c"){
      //   websocket.close();
      //   return;
      }else if(msg === "space"){
        speed = (speed==0) ? 1 : 0;
        console.log("New speed: "+speed);
/*      }else if(msg === "f"){
        toggleFullscreen();
      }else if(msg === "c"){
        if(connected){
          device_controls.disconnect();
        }else{
          device_controls.connect();
        }
        connected = !connected;*/
      }else{
        var ALPHA_ROT = 0.1;
        if(msg === "a"){
          go(-1, 0, 0);
        }else if(msg === "d"){
          go(1, 0, 0);
        }else if(msg === "s"){
          go(0, 0, 1);
        }else if(msg === "w"){
          go(0, 0, -1);
        }else if(msg === "q"){
          go(0, 1, 0);
        }else if(msg === "e"){
          go(0, -1, 0);
        }else if(msg === "Left"){
          camera.rotateY(ALPHA_ROT);
        }else if(msg === "Right"){
          camera.rotateY(-ALPHA_ROT);
        }else if(msg === "Up"){
          camera.rotateX(ALPHA_ROT);
        }else if(msg === "Down"){
          camera.rotateX(-ALPHA_ROT);
        }
      }
    }

    function keyEvent(event) {
      var key = event.keyCode || event.which;
      var keychar = String.fromCharCode(key).toLowerCase();
      if(key==32){
        keychar = "space";
      }else if(key==37){
        keychar = "Left";
      }else if(key==38){
        keychar = "Up";
      }else if(key==39){
        keychar = "Right";
      }else if(key==40){
        keychar = "Down";
      }
      console.log("Keyboard: keyCode "+key+", keychar "+keychar);
      handle_char(keychar);
    }
    
    var vector = new THREE.Vector3(0,0,0);
    function go(x,y,z){
      vector.set(-x,-y,-z);
      vector.applyQuaternion( camera.quaternion );
      scene.position.add(vector);
      console.log(scene.position)
    }
    
    function closeWebSocket(){
      if(websocket != null){
        websocket.send('{"message": "byebye"}')
        websocket.close();
        websocket = null;
      }
    }

    // and now from the boilerplate:
    window.addEventListener('load', onLoad);

  </script>
</html>
